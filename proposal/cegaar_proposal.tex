\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{xspace}
\usepackage{tabu}
\usepackage[%
  hyperindex,%
  plainpages=false,%
  pdfusetitle]{hyperref}
\usepackage[all]{hypcap}
\usepackage{cite}
\usepackage{booktabs}
\usepackage{url}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{tikz}
\usetikzlibrary{positioning,shapes.geometric, arrows,automata, decorations.pathreplacing, calc}
\usepackage{pgf}
\usepackage{slantsc}
\usepackage{geometry}
\usepackage{amssymb}
\usepackage{subcaption}
\usepackage{float}
\usepackage{pgf}
\usepackage{slashbox}
\usepackage{pgfgantt}
\usepackage{wrapfig}
\usepackage{pdflscape}



\usepackage[%disable,%
  colorinlistoftodos,%
  color=cyan!50!white,%
  bordercolor=cyan!50!black]{todonotes}

%%%%%%%%%%%% Colors 
%% a somewhat friendly scheme for 5 different colors 
\definecolor{g1}		{RGB}{215,25,28} % a kind of red
\definecolor{g2}		{RGB}{253,174,97} % a kind of orange
\definecolor{g3}		{RGB}{255,255,191} % a kind of yellow
\definecolor{g4}		{RGB}{171,217,233} % a kind of light blue 
\definecolor{g5}		{RGB}{44,123,182} % a kind of dark blue 

\definecolor{gr1}		{RGB}{250, 250, 250}
\definecolor{gr2}		{RGB}{229, 229, 229} % some grey

% color of interpolants
\definecolor{grey}{RGB}{200,200,200}

%color for pictures
\colorlet{outlineblue}		{g5}
\colorlet{fillblue}			{g4}
\colorlet{darkback}			{gr2}
\colorlet{lightback}		{gr1}
\colorlet{stmtcolor}		{gr2} %default statement color
\colorlet{subgraphcolor}	{g3} %default statement color


%%%%%%%%%%%% Setup
\newtheorem{name}{Printed output}
\newtheorem{mydef}{Definition}

\hypersetup{
colorlinks=true,        % false: boxed links; true: colored links
linkcolor=g1,        % color of internal links
citecolor=g1,        % color of links to bibliography
filecolor=g1,        % color of file links
urlcolor=g1          % color of external links
}


\lstdefinestyle{boogie}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  numbers=left,
  xleftmargin=.6cm
}

\lstset{escapechar=@,style=boogie}

%%%%%%%%%%%% Comments
\newif\iffinal
%\finaltrue % comment out to remove comments 
 
\iffinal
\newcommand\mycom[1]{}
\else
\newcommand\mycom[1]{#1}
\overfullrule=1mm
\fi
\setlength\parindent{0pt}

\newcommand{\WidestEntry}{$\psi_{global}$}%
\newcommand{\SetToWidest}[1]{\makebox[\widthof{\WidestEntry}]{$#1$}}%

\newcommand{\jw}[1]{\mycom{\todo[color=blue!40,inline]{\small JW: #1}}}
\newcommand{\dd}[1]{\mycom{\todo[color=orange!40,inline]{\small DD: #1}}}
\newcommand{\ts}[1]{\mycom{\todo[color=green!40,inline]{\small TS: #1}}}


\newcommand{\all}[1]{\mycom{\todo[color=green!40,inline]{\small #1}}}
\newcommand{\meta}[1]{\mycom{\todo[color=blue!10,inline,caption={Beschreibung},nolist]{\setlist{nolistsep}\small #1}}}
\newcommand{\xxx}{\mycom{\stfootcol{Placeholder}{blue!20}\xspace}}
\newcommand{\cn}{\mycom{\stfootcol{Cite}{blue!20}\xspace}}


\begin{document}
	\newcommand{\HorizontalLine}{\rule{\linewidth}{0.3mm}}
	
		\begin{center}
		{\scshape\Large Master Project \par}
		\vspace{1.5cm}
		{\huge\bfseries Trace Abstraction with Accelerated Interpolants \par}
		{\Huge\itshape Proposal \par}
		\vspace{1cm}
		{\large \scshape Jonas Werner\par}
		\vspace{0.5cm}
		{\today \vspace{2cm}} 
		
		\end{center}

\section{Introduction}
Assume we want to verify whether a program is correct or not. A possible method is to construct the program's control-flow graph and using an automata-based instance of the CEGAR scheme, called trace abstraction, on it. Trace abstraction aims at constructing automata \cite{10.1007/978-3-642-39799-8_2} from infeasible traces leading to an error location, so called error traces, such that the language of the union of these automata are a superset of the language recognized by the program's control-flow graph. \par 
For each possible error trace check its feasibility, in case that the trace is feasible, the program is incorrect. If the trace is infeasible it is possible to compute a generalization that can exclude more error traces. A common strategy \cite{10.1007/978-3-642-03237-0_7} to calculate a generalization is using Craig interpolation \cite{craig_1957}. \par 
However these interpolants are not guaranteed to be the most general and with that not guaranteed to exclude many traces. This issue is most notably in program loops. Assume that the given program contains a loop with guard $x < 5000$, $x$ being an integer variable. It is possible that trace abstraction cannot generate an interpolant that excludes every loop iteration, leading to the need of proving every of the 5000 possible error traces individually. \par
A possible solution for this problem would be accelerating the loop, meaning computing its transitive closure, and applying interpolation on that. \par This project aims at implementing exactly that. 
The goal is to combine interpolation and loop acceleration on the basis of the work of Hojjat et al \cite{10.1007/978-3-642-33386-6_16} in the software analysis framework \\ Ultimate \cite{Zitat02}. \par
The remainder of this proposal is structured as follows, chapter 2 will give an overview over needed background information, like a more detailed look at trace abstraction, loop acceleration, and the combination of interpolation and acceleration. Chapter 3 will detail the approach this project will take to implement accelerated interpolation in Ultimate, and finally an outline of the project's deliverables and schedule.

\section{Background}
This project aims at combining loop acceleration and interpolant calculation based on the findings of Hojjat et al \cite{10.1007/978-3-642-33386-6_16}, however, instead of utilizing a CEGAR-scheme with predicate abstraction, it will be implemented as an automata-based CEGAR-scheme, called trace abstraction. \par
This section will introduce the basic ideas behind trace abstraction, loop acceleration, and finally accelerated interpolants.

\subsection{Interpolating Trace Abstraction}
Given a program $P$ and its control-flow graph $A_P = (Loc, \Delta, \ell_{0}, \ell_E)$, where $Loc$ is a set of control states, $\Delta$ is a set of triples $(\ell, stm, \ell')$ representing program transitions with $\ell, \ell' \in Loc$ and program statement $stm$, $\ell_{init}$ being the initial location, and $\ell_E$ being an error location. One can interpret the control-flow graph as an automaton with $\ell_E$ being an accepting state. \par To check the reachability of $\ell_E$, and with that correctness of $P$, use trace abstraction with interpolation according to the following paradigm \cite{10.1007/978-3-642-03237-0_7}:
\begin{itemize}
	\item[1.] Get an error trace which starts at $\ell_0$ and ends in $\ell_E$:
	\begin{equation*}
			 \ell_{0} \xrightarrow{\text{$stm_1$}} \ell_1 \xrightarrow{\text{$stm_2$}} \cdots \xrightarrow{\text{$stm_{n-1}$}} \ell_{n-1} \xrightarrow{\text{$stm_{n}$}} \ell_{E}
	\end{equation*}
	With each $(\ell_i, stm_i, \ell_{i + 1}) \in \Delta$.
	\item[2.] Construct an infeasibility proof. \\ In case that the trace is proven feasible, the program is incorrect
	\item[3.] Use the infeasibility proof to calculate interpolants. \\
	Construct an automaton, $\mathcal{A}_i$, from the interpolants.
	\item[4.] If the language $\mathcal{L(A_P)}$, that is recognized by the program's control-flow graph, is a subset of the union of languages recognized by the constructed automata: $\mathcal{L(A_P)} \subseteq \mathcal{L(A}_1) \cup ... \cup \mathcal{L(A}_i)$ then the program is correct, else start again at step 1.
\end{itemize}
The interpolants generated in step 3 serve to generalize the infeasibility proof to exclude other possible error traces. However, the interpolants are not guaranteed to be general enough to exclude infinitely many error traces. Which poses a problem for loops. In the following we introduce a way to exclude an infinite number of traces going through a loop.

\subsection{Trace Schemes}
To make the exclusion of error traces through a loop possible, we need to preprocess error traces. \\
Assume we are given the following error trace $\tau$:
\begin{equation*}
\tau: \ell_0 \xrightarrow{\text{$stm_1$}} \ell_1 \xrightarrow{\text{$stm_2$}} \ell_2 \xrightarrow{\text{$stm_3$}} \ell_3 \xrightarrow{\text{$stm_4$}} \ell_2 \xrightarrow{\text{$stm_5$}} \ell_E
\end{equation*}
We see there is a loop from $\ell_2$ to $\ell_3$ and back to $\ell_2$.  \\ \\
To be able to efficiently exclude the loop, calculate the composition of the loop's statements. \\
This composition is then used to remove the loop from the trace, resulting in a trace scheme:
\begin{equation*}
\tau':\ell_0 \xrightarrow{\text{$stm_1$}} \ell_1 \xrightarrow{\text{$stm_2$}} \overset{stm_3\ \circ \ stm_4}{\overset{\curvearrowright}{\ell_2}} \xrightarrow{\text{$stm_5$}} \ell_E
\end{equation*}
Assume the trace scheme is infeasible, it is possible to construct an interpolant sequence, that is,
however, not guaranteed to be useful. This is where the loop acceleration is needed.

\subsection{Loop Acceleration}
The goal of acceleration is to compute a loop's transitive closure. In general, this is not possible as the transitive closure consists of infinitely many disjunctions. There are loops that can be expressed as so called octagon relations \cite{DBLP:journals/corr/abs-cs-0703084}. \\
These relations have a certain constraint of the following form: 
\begin{equation*}
	\pm x_i \pm x_j \leq c_{i,j}
\end{equation*}
With integer variables $x_i, x_, c_{i,j}$ \\
It has been shown, that the transitive closure of an octagonal relation can be efficiently computed \cite{10.1007/978-3-642-14295-6_23}.
\subsection{Meta Trace Schemes}
The transitive closure of a loop contains every trace going through it. To make use of a loop acceleration, we need to pull apart the looping location $\ell_2$ by introducing so called meta-transitions of the form:
\begin{equation*}
	\overset{stm_3\ \circ \ stm_4}{\overset{\curvearrowright}{\ell_2}} \Rightarrow \hspace*{1cm} \ell_2' \xrightarrow{\text{$(stm_3 \circ stm_4)^*$}} \ell_2''
\end{equation*}
Where $(stm_3 \circ stm_4)^*$ symbolizes the calculated transitive closure of the loop. \par
Using meta-transitions, we can transform our trace scheme into a meta-trace:
\begin{equation*}
	\bar{\tau}: \ell_0 \xrightarrow{\text{$stm_1$}} \ell_1 \xrightarrow{\text{$stm_2$}} \ell_2' \xrightarrow{\text{$(stm_3 \circ stm_4)^*$}} \ell_2'' \xrightarrow{\text{$stm_5$}} \ell_E
\end{equation*}
The feasibility of the meta-trace is the same as the trace scheme before. When we assume that it is infeasible, we can generate an interpolant sequence:
\begin{equation*}
I_{\bar{\tau}}: \langle \top, I_1, I_2', I_2'', \bot  \rangle
\end{equation*}
To guarantee inductiveness to the loop, we have to compute the strongest post of each interpolant, that coincide with a location in the loop, and its transitive closure:
\begin{equation*}
I_{\bar{\tau}}^{post}: \langle \top, I_1, post(I_2', stm_3 \circ stm_4), I_2'', \bot  \rangle
\end{equation*}
This sequence is now general enough to exclude infinitely many traces.
\section{Approach}
We want to implement accelerated interpolation into the software verification framework Ultimate \cite{Zitat02}. Ultimate consists of multiple different libraries that can be executed in serial to form so called toolchains. There are already toolchains implementing trace abstraction as described above. This project extends these toolchains with accelerated interpolation by creating a new interpolating trace checking library. \par 
This library will be used for step 3 of the trace abstraction paradigm. For that it has to fulfill the following specifications: 
\begin{itemize}
	\item Computing loop accelerations of octagonal relations using ultimately periodic relations as shown by Bozga et al \cite{10.1007/978-3-642-14295-6_23}. 
	\item Construct trace schemes from given error traces and extend them using loop acceleration to meta schemes as presented by Hojjat et al \cite{10.1007/978-3-642-33386-6_16}.
	\item Check meta schemes' feasibility
	\item Construct interpolants for infeasible meta schemes to be used in trace abstraction.
\end{itemize}
This project is finished when this library has been implemented, tested, and evaluated by using it on several verification tasks. \\ \\
Master projects award 12 ECTS points which translates to 12 weeks of work. Resulting in the following approach:
\begin{itemize}
	\item[1.] \textsl{Understanding the Matter:} \\
	Grasp how the combination of loop acceleration and interpolation works. \\
	Moreover, there have been previous projects that implemented the basis \cite{ClausThesis} and the ultimately periodic acceleration scheme itself \cite{JillThesis} in Ultimate. It is important to understand those implementations before trying to adapt them for the usage of accelerated interpolants. \\ \\
	\textsl{Duration in weeks:} 1 \\\\
	\textsl{Result}: Being able to use the previous work and having an understanding on how to implement an accelerated interpolation library.
	\item[2.] \textsl{Implement Trace Scheme Transformation:} \\
	The accelerated interpolation library should be able to transform a given error trace into a trace scheme. \\\\
	\textsl{Duration in weeks:} 1 \\\\
	\textsl{Result}: Given an error trace, accelerated interpolation is able to transform it into a trace scheme.
	
	\item[3.] \textsl{Implement Own Version of Loop Acceleration:} \\
	Implement a way of using Fast Acceleration of Ultimately Periodic Relations in the accelerated interpolation library. \\ \\
	\textsl{Duration in weeks:} 3 \\ \\
	\textsl{Result}: Accelerated interpolation is able to construct the transitive closure of loops to use for interpolant generation
	
	\item[4.] \textsl{Combining Trace Schemes and Loop Acceleration:} \\
	Accelerated interpolation can construct meta-schemes from trace schemes by inserting the transitive closure of the loop, prove its feasibility, and furthermore, is able to generate interpolants from the meta-scheme. \\ \\
	\textsl{Duration in weeks:} 3 \\\\
	\textsl{Result}: Accelerated interpolation returns a sequence of interpolants for use in the trace abstraction paradigm, or returns that the program is incorrect, depending on the feasibility of an error trace.
	
	\item[5.] \textsl{Evaluating the Library:} \\
	Search for possible bugs and compare it to other trace checkers, such as PDR. \\\\
	\textsl{Duration in weeks:} 2 \\\\
	\textsl{Result}: A bugfree accelerated interpolation library and data comparing it to other trace checkers.
	
	\item[6.] \textsl{Writing a Documentation about the Project:} \\
	Write in more detail than this proposal how accelerated interpolation works, and what new knowledge we discovered during this project \\\\
	\textsl{Duration in weeks:} 2 \\\\
	\textsl{Result}: A written documentation about this project.
\end{itemize}
\begin{landscape}
	\section{Schedule}
	\pagenumbering{gobble}
	This schedule illustrates the approach and shows the sequence of the individual tasks. \\ \\
	\hspace*{-4cm}
	\begin{tikzpicture}
	\begin{ganttchart}[hgrid, vgrid, x unit=1.7cm, bar height=.6,, title height=1, canvas/.append style={alias=frame}
	]{1}{12}
	
	\gantttitle{Time in weeks}{12} \ganttnewline
	
	\gantttitlelist{1,...,12}{1} \\
	
	
	\ganttbar{1. Understanding}{1}{1}
	
	% A NEW BAR FOR EACH WITH INLINE
	
	\ganttbar[inline]{}{1}{1} \ \\
	
	\ganttbar{2. Trace Scheme}{2}{2}
	\ganttbar[inline]{}{2}{2} \ \\
	
	\ganttbar{3. Acceleration}{3}{5}
	\ganttbar[inline]{}{3}{5} \ \\
	
	\ganttbar{4. Combining}{6}{8}
	\ganttbar[inline]{}{6}{8} \ \\
	
	\ganttbar{5. Evaluating}{9}{10}
	\ganttbar[inline]{}{9}{10} \ \\
	
	\ganttbar{6. Writing}{11}{12}
	\ganttbar[inline]{}{11}{12}
	\end{ganttchart}
	\useasboundingbox (frame.south west) rectangle (frame.north east);
	\end{tikzpicture}
	
\end{landscape}
\pagebreak
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain}
\bibliography{bib}

	
\end{document}