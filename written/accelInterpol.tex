\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{xspace}
\usepackage{tabu}
\usepackage[%
  hyperindex,%
  plainpages=false,%
  pdfusetitle]{hyperref}
\usepackage[all]{hypcap}
\usepackage{cite}
\usepackage{booktabs}
\usepackage{url}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{tikz}
\usetikzlibrary{positioning,shapes.geometric, arrows,automata, decorations.pathreplacing, calc}
\usepackage{pgf}
\usepackage{slantsc}
\usepackage{geometry}
\usepackage{amssymb}
\usepackage{subcaption}
\usepackage{float}
\usepackage{pgf}
\usepackage{slashbox}
\usepackage{pgfgantt}
\usepackage{wrapfig}
\usepackage{pdflscape}

	

\newcommand{\tf}{\ensuremath{\varphi}\xspace}
\newcommand{\ctf}{\ensuremath{\widehat{\varphi}}\xspace}
\newcommand{\invars}{\ensuremath{In}\xspace}
\newcommand{\outvars}{\ensuremath{Out}\xspace}
\newcommand{\auxvars}{\ensuremath{Aux}\xspace}

\newcommand{\WidestEntry}{$\psi_{global}$}%
\newcommand{\SetToWidest}[1]{\makebox[\widthof{\WidestEntry}]{$#1$}}%


\usepackage[%disable,%
  colorinlistoftodos,%
  color=cyan!50!white,%
  bordercolor=cyan!50!black]{todonotes}

%%%%%%%%%%%% Colors 
%% a somewhat friendly scheme for 5 different colors 
\definecolor{g1}		{RGB}{215,25,28} % a kind of red
\definecolor{g2}		{RGB}{253,174,97} % a kind of orange
\definecolor{g3}		{RGB}{255,255,191} % a kind of yellow
\definecolor{g4}		{RGB}{171,217,233} % a kind of light blue 
\definecolor{g5}		{RGB}{44,123,182} % a kind of dark blue 

\definecolor{gr1}		{RGB}{250, 250, 250}
\definecolor{gr2}		{RGB}{229, 229, 229} % some grey

% color of interpolants
\definecolor{grey}{RGB}{200,200,200}

%color for pictures
\colorlet{outlineblue}		{g5}
\colorlet{fillblue}			{g4}
\colorlet{darkback}			{gr2}
\colorlet{lightback}		{gr1}
\colorlet{stmtcolor}		{gr2} %default statement color
\colorlet{subgraphcolor}	{g3} %default statement color


%%%%%%%%%%%% Setup
\newtheorem{name}{Printed output}
\newtheorem{mydef}{Definition}

\hypersetup{
colorlinks=true,        % false: boxed links; true: colored links
linkcolor=g1,        % color of internal links
citecolor=g1,        % color of links to bibliography
filecolor=g1,        % color of file links
urlcolor=g1          % color of external links
}


\lstdefinestyle{boogie}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  numbers=left,
  xleftmargin=.6cm
}

\lstset{escapechar=@,style=boogie}

%%%%%%%%%%%% Comments
\newif\iffinal
%\finaltrue % comment out to remove comments 
 
\iffinal
\newcommand\mycom[1]{}
\else
\newcommand\mycom[1]{#1}
\overfullrule=1mm
\fi
\setlength\parindent{0pt}

\newcommand{\jw}[1]{\mycom{\todo[color=blue!40,inline]{\small JW: #1}}}
\newcommand{\dd}[1]{\mycom{\todo[color=orange!40,inline]{\small DD: #1}}}
\newcommand{\ts}[1]{\mycom{\todo[color=green!40,inline]{\small TS: #1}}}


\newcommand{\all}[1]{\mycom{\todo[color=green!40,inline]{\small #1}}}
\newcommand{\meta}[1]{\mycom{\todo[color=blue!10,inline,caption={Beschreibung},nolist]{\setlist{nolistsep}\small #1}}}
\newcommand{\xxx}{\mycom{\stfootcol{Placeholder}{blue!20}\xspace}}
\newcommand{\cn}{\mycom{\stfootcol{Cite}{blue!20}\xspace}}


\begin{document}
	\newcommand{\HorizontalLine}{\rule{\linewidth}{0.3mm}}
	
		\begin{center}
		{\scshape\Large Master Project \par}
		\vspace{1.5cm}
		{\huge\bfseries Accelerated Interpolation \par}
		\vspace{1cm}
		{\large \scshape Jonas Werner\par}
		\vspace{0.5cm}
		{\today \vspace{2cm}} 
		
		\end{center}

\section{Introduction}
Assume we want to verify whether a program fulfills a given safety property, for that the program's control-flow graph can be used. The control-flow graph represents every possible trace that can be taken by a program execution. Executions that violate the safety property end in a so called error location. Error traces are traces in the control-flow graph that start in the initial node and end in the error location. The goal is to check if there are feasible error traces.
For this purpose one can apply an automata-based instance of the CEGAR scheme, called trace abstraction, on the program's control-flow graph. \\

Trace abstraction aims at constructing automata \cite{10.1007/978-3-642-39799-8_2} from infeasible error traces. When the language recognized by the program's control-flow graph is a subset of these automata, it means, every possible error trace, and by that execution which ends in an error location, is infeasible. Proving that the program fulfills the safety property. If there is a single feasible error trace, then the program violates the safety property.\\
\par 
If an error trace is infeasible there is an infeasibility proof. Using this proof one can construct an automaton, which excludes the original error trace from the control-flow graph. However, this excludes only one error trace, making this approach not very efficient. To exclude more than one error trace, one can try to compute a generalization of the infeasibility proof. \par

A common strategy is \cite{10.1007/978-3-642-03237-0_7} to calculate a generalization using Craig interpolation \cite{craig_1957}, where an SMT-solver computes a sequence of interpolants from an infeasibility proof. \par 
But, it is not guaranteed that these interpolants are more general. This issue is most notably in program loops. Assume that the given program contains a loop with guard $x < 5000$, $x$ being an integer variable. It is possible that the computed interpolant sequence does not exclude every loop iteration, leading to the need of disproving every of the 5000 possible error traces individually. \\ \\
A solution for this problem is accelerating the loop, meaning computing its transitive closure, and calculating interpolants on that. \par This project aims at implementing exactly that. 
The goal is to combine interpolation and loop acceleration on the basis of the work of Hojjat et al \cite{10.1007/978-3-642-33386-6_16} in the software analysis framework \\ Ultimate \cite{Zitat02}. \par
The remainder of this proposal is structured as follows. Chapter 2 will give an overview of needed background information, like a more detailed look at trace abstraction, loop acceleration, and the combination of interpolation and acceleration. Chapter 3 will detail the approach this project will take to implement accelerated interpolation in Ultimate, and finally an outline of the project's deliverables and schedule.

\section{Background}
This project aims at combining loop acceleration and interpolant calculation based on the findings of Hojjat et al. \cite{10.1007/978-3-642-33386-6_16}, however, instead of utilizing a CEGAR-scheme with predicate abstraction, it will be implemented as an automata-based CEGAR-scheme, called trace abstraction. \par
This section will introduce the basic ideas behind trace abstraction, loop acceleration, and finally accelerated interpolants.

\subsection{Interpolating Trace Abstraction}
To apply interpolating trace abstraction one firstly needs to know what a program is.
\begin{mydef}
	A program $\texttt{P} = (V, \mu, Stm)$ is a triple consisting of the set of program variables $V = \{v_0, ..., v_n\}$, a map $\mu: v_i \rightarrow D_i$ that assigns each variable a domain $D_i$, and a set of program statements $Stm = \{st_0, ..., st_n\}$.
\end{mydef}
To illustrate programs, consider the following program code:
	\begin{align*}
		&\texttt{1: int x := 0}; \\
		&\texttt{2: while x < 6;} \\
		&\texttt{3: \hspace*{2em} x := x + 2;} \\
		&\texttt{4: end while} \\
		&\texttt{5: assert x == 6;}
	\end{align*}
	\captionof{figure}{Example Program Code $C$.}
	\label{fig:square}
\vspace*{1cm}
The code creates program $P_c = (V_c, \mu_c, S_c)$ consisting of:
\begin{itemize}
	\item $V_c = \{x\}$
	\item $\mu_c =(x \mapsto \mathbb{Z}) $
	\item $Stm_c = \{ \texttt{x := 0, \texttt{x < 6}, \texttt{x >= 6}, \texttt{x := x + 2}, \texttt{x == 6}, \texttt{x != 6} }\}$
\end{itemize}

Each program variable has a domain, so that it is possible to assign a concrete value.
\begin{mydef}
	A variable valuation of a program variable $v \in V$ is a function $\rho: v \rightarrow \mu(v)$.  Assigning it a value from its domain.
\end{mydef}
Extending a single variable valuation to a valuation of every program variable we get a program state.
\begin{mydef}
	A program state $\sigma$ is a function assigning each program variable $v_i \in V$, \ $0 \leq i \leq n$ a variable valuation $\rho_i$. The set $S$ denotes the set of all program states.
\end{mydef}
To use program variables in a logical context, we map each program variable $v \in V$ to a tuple $(tv, c, c')$ that consists of: 
	\begin{itemize}
		\item A termvariable $v_i$ that is used in logical operations.
		\item A constant $c_x$
		\item A primed constant $c_x'$
\end{itemize}
For example, assume we have the program variable $x$. $x$ is mapped to the tuple $(x_0, c_x, c'_x)$.  \\ \\
Program statements can alter the program state, meaning they can change variable valuations, Leading from one program state to another. To model these changes, we introduce transformulas.
\begin{mydef}
	A transformula is a binary relation denoting the current program state and its successor state. It is defined as a tuple $\psi = (\invars, \outvars, \auxvars, \tf, \ctf)$ with 
	\begin{itemize}
		\item $\invars : x \mapsto x_i$ a mapping from program variables to unprimed termvariables called the in-variables
		\item $\outvars : x \mapsto x_j'$ a mapping from program variables to primed termvariables called the out-variables
		\item $\auxvars: \{ v_i \}$ a set of termvariables $v_i$ that only exist in the context of this transformula called the aux-variables,
		\item $\tf$ is a formula over termvariables from $\invars$, $\outvars$, and $\auxvars$. The actual transformula.
		\item $\ctf$ is the closed formula of $\tf$ where every in-variable is replaced by the unprimed constant of the corresponding program variable and every out-variable is replaced by the primed constant of the corresponding program variable. For every aux-var there is a newly created constant.
		%\item $PreProc$ is the procedure in which the program is before executing the TF.
		%\item $SuccProc$ is the procedure the program is in after executing the TF.
	\end{itemize}
The trivial transformula $\varepsilon$ is defined as: $\varepsilon = (\emptyset, \emptyset, \emptyset, true, true)$
\end{mydef}
%

\begin{mydef}
	A control flow graph, CFG, is a directed graph $G = (Loc, \Delta, \ell_{init}, L_E, st)$ of a program with the following characteristics:
	\begin{itemize}
		\item  Loc is a set of program locations
		\item $\Delta$ is a set of internal program transitions consisting of tuples $(\ell, \ell')$ with $\ell, \ell' \in Loc$
		\item $\ell_{init} \in Loc$ is the initial location
		\item $L_E \subseteq Loc$ a set of error locations
		\item st: $\psi \rightarrow \Delta $ is a labeling function that assigns a transformula to each transition in $\Delta$.
	\end{itemize}
\end{mydef} \noindent
%

Assume we are again given program $P_c$ from above. Its corresponding CFG $G_c$ is defined as $G_c = (Loc_c, \Delta_c, \ell_{init}, L_E, st_c)$ with: 
\begin{itemize}
	\item $Loc_c = \{\ell_0, \ell_1, \ell_2, \ell_3, \ell_4, \ell_E\}$
	\item $\Delta_c =\{(\ell_0, \ell_1), (\ell_1, \ell_2), (\ell_2, \ell_1), (\ell_1, \ell_3), (\ell_3, \ell_4), (\ell_3, \ell_E)\} $
	\item $\ell_{init} = \ell_{0}$
	\item $L_E = \{\ell_E\}$
	\item $st_c = ( \psi_0 \mapsto (\ell_0, \ell_1) , \psi_1 \mapsto (\ell_1, \ell_2), \psi_2 \mapsto (\ell_2, \ell_1), \psi_3 \mapsto (\ell_1, \ell3), \psi_4 \mapsto (\ell_3, \ell_4), \psi_5 \mapsto (\ell_3, \ell_E))$ 
\end{itemize}
And transformulas: 
\begin{itemize}
	\item $\psi_0 = (\emptyset, \{x \mapsto x_0'\}, \emptyset, (x_0' = 0), (c_x' = 0))$
	\item $\psi_1 = ( \{x \mapsto x_1\}, \{x \mapsto x_1'\}, \emptyset, (x_1 < 6 \land x_1' = x_1), (c_x < 6 \land c_x' = c_x))$
	\item $\psi_2 = (\{ x \mapsto x_2\}, \{ x \mapsto x_3' \}, \emptyset, (x_3' = x_2 + 2), (c_x' = c_x + 2))$
	\item $\psi_3 = (\{x \mapsto x_4\}, \{x \mapsto x_4'\}, \emptyset, (6 \leq x_4 \land x_4' = x_4), (6 \leq c_x \land c_x' = c_x))$
	\item $\psi_4 = (\{x \mapsto x_5\}, \{x \mapsto x_5'\}, \emptyset, (x_5 = 6 \land x_5' = x_5), (c_x = 6 \land c_x' = c_x))$
	\item $\psi_5 = (\{x \mapsto x_6\}, \{x \mapsto x_6'\}, \emptyset, (x_6 \neq 6 
	\land x_6' = x_6), (c_x \neq 6 \land c_x' = c_x))$
\end{itemize}

For readability we represent $G_c$ graphically where edge is labelled with $\varphi_i$ of transformula $\psi_i$.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=4cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=1.4}
		initial text =]
		\node[state, initial above](1){$\ell_0$};
		
		\node[state] (2) [below of=1] {$\ell_1$};
		
		\node[state] (3) [left of=2] {$\ell_2$};
		
		\node[state] (4) [right of=2] {$\ell_3$};
		
		\node[state] (5) [below of=4] {$\ell_E$};
		
		\node[state] (6) [right of=4] {$\ell_4$};
		
		\path (1) edge node {$x_0' = 0$} (2)
		(2) edge [bend right] node [above]{$x_1 < 6 \land x_1' = x_1$} (3)
		(3) edge [bend right] node [below]{$x_3' = x_2 + 2$} (2)
		(2) edge node {$6 \leq x_4 \land x_4' = x_4$} (4)
		(4) edge node {$x_5 = 6 \land x_5' = x_5$} (5)
		(4) edge node {$x_6 \neq 6 \land x_6' = x_6$} (6)
		;
	\end{tikzpicture}
	\captionof{figure}{Control-Flow Graph $G_c$.}
	\label{fig:rect}
\end{figure}
\vspace*{2em}
\medskip
To prove safety of a program, we need to check if there are traces from the initial location to an error location.
\begin{mydef}
	Given a CFG $G = (Loc, \Delta, \ell_{init}, L_E, st)$ a program trace $\tau$ is a sequence of transformulas $\psi_0, \psi_1, \cdots, \psi_n$, where $st(\psi_0) = (\ell_{init}, \ell_i)$ \\
	If $st(\psi_n) = (\ell_j, \ell_E)$ with $\ell_E \in L_E$ then the trace is called an error trace.
\end{mydef}

Program traces can be graphically represented, again for readability we replace transformula $\psi_i$ by its formula $\varphi_i$:
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=2.5cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=2}
		initial text =]
		
		\node[state](1){$\ell_0$};
		
		\node[state] (2) [right of=1] {$\ell_1$};
		
		\node[] (3) [right of=2] {$\cdots$};
		
		\node[state] (4) [right of=3] {$\ell_{n-1}$};
		
		\node[state] (5) [right of=4] {$\ell_n$};
		
		
		\path (1) edge node {$\varphi_0$} (2); 
		\path (2) edge node {$\varphi_1$} (3); 
		\path (3) edge node {$\varphi_{n-1}$} (4);
		\path (4) edge node {$\varphi_n$} (5); 
		;
	\end{tikzpicture}
	\captionof{figure}{Graphical Representation of a Program Trace.}
\end{figure}

It is possible to model multiple transitions in one transformula using the concatenation operator:
\begin{mydef}
	A concatenation of two Transformulas 
	\begin{equation*}
		\psi_{1 \circ 2} = \psi_1 \circ \psi_2 = (\invars_{1 \circ 2}, \outvars_{1 \circ 2}, \auxvars_{1 \circ 2}, \varphi_{1 \circ 2}, \widehat{\varphi}_{1 \circ 2})
	\end{equation*}  yields one Transformula describing the behaviour of both of them. With
	\begin{itemize}
		\item $\invars_{1 \circ 2} = \invars_1$
		\item For $\outvars_{1 \circ 2}$ we have to distinguish three cases cases: 
		\begin{itemize}
			
			\item[I:] $(x \mapsto x_i') \in Out_1$ and $x  \not\in entries(Out_2)$, meaning program variable is solely modified in $\psi_1$. In that case the out-variable of the concatenation is the same as the out-variable of $\psi_1: $ $\outvars_{1 \circ 2} \cup (x \mapsto x_i')$ 
			\item[II:] $(x \mapsto x_j') \in Out_2$ and $x  \not\in entries(Out_1)$, meaning program variable is solely modified in $\psi_2$. In that case the out variable of the concatenation is the same as the out-variable of $\psi_2: $ $\outvars_{1 \circ 2} \cup (x \mapsto x_j')$ 
			\item[III:] $x \in entries(Out_1)$ and $x \in entries(Out_2)$, meaning program variable $x$ is modified in both transformulas which can create a term variable naming conflict. 
			In this case $\outvars_{1 \circ 2} \cup (x \mapsto \widehat{x_j}')$ where $\widehat{x_j}'$ is a fresh term variable that has not been used before.
			
		\end{itemize}
		
		\item $\auxvars_{1 \circ 2} = \{ \widehat{v_i} \ |\ v_i \in \auxvars_1 \cup \auxvars_2 \cup range(\invars_2) \text{ where } \widehat{v_i} \text{ is a fresh variable of } v_i \}$
		\item $\varphi_{1 \circ 2}$ = $\varphi_1[x_i' / x_j, v_i / \widehat{v_i} ] \land \varphi_2[v_j / \widehat{v_j}, x_j' / \widehat{x_j}']$, where
		\begin{itemize}
			\item $\varphi_1[x_i' / x_j, v_i / \widehat{v_i} ] $ is $\varphi_1$ where we substitute every program variable mapping $(x \mapsto x_i') \in \outvars_1$ with $(x \mapsto x_j) \in \invars_2$ and each $v_i \in \auxvars_1$ with a fresh variable $\widehat{v_i}$.
			\item  $\varphi_2[v_j / \widehat{v_j}, x_j / \widehat{x_j}]$ is $\varphi_2$ where we substitute each $v_j \in \auxvars_2$ with a fresh variable $\widehat{v_j}$ and each mapping $(x \mapsto x_j') \in \outvars_2$, that fulfills out-variable case $III$, with $(x \mapsto \widehat{x_j}')$.
		\end{itemize} 
		\item $\widehat{\varphi}_{1 \circ 2}$ is the closed formula of $\varphi_{1 \circ 2}$ where every in-variable is replaced by the unprimed constant of the corresponding program variable and every out-variable is replaced by the primed constant. For every every $v_i \in \auxvars_{1 \circ 2}$ we introduce a fresh constant.
	\end{itemize}
\end{mydef}

\jw{Todo Interpolants}
For example, consider the conjunction:
\begin{equation}
	x_0 = 5 \land x_0 \leq 3
\end{equation}
Which is unsatisfiable. A derived interpolant is $x_0 = 5$ \\
	Interpolanten -> Sequenzinterpolanten \cite{10.1007/11691372_33}-> Interpolantenautomat

\vspace*{2cm}



Using definitions 1 and 2 we can define trace abstraction as a technique of proving or disproving safety for a given program by checking for reachability of an error location.


	 To check reachability of an error location $\ell_E \in L_{Err}$, use trace abstraction with interpolation according to the following paradigm \cite{10.1007/978-3-642-03237-0_7}: \\
	 Given 	a program $\texttt{P}$ and its control-flow graph $G_P = (L, \Delta, \ell_{0}, L_{Err})$
	\begin{itemize}
		\item[1.] Search $G_P$ for a program trace that starts at $\ell_0$ and ends in $\ell_E$:
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=2.5cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=2}
		initial text =]
		
		\node[state](1){$\ell_0$};
		
		\node[state] (2) [right of=1] {$\ell_1$};
		
		\node[] (3) [right of=2] {$\cdots$};
		
		\node[state] (4) [right of=3] {$\ell_{n-1}$};
		
		\node[state] (5) [right of=4] {$\ell_E$};
		
		
		\path (1) edge node {$\varphi_0$} (2); 
		\path (2) edge node {$\varphi_1$} (3); 
		\path (3) edge node {$\varphi_{n-1}$} (4);
		\path (4) edge node {$\varphi_n$} (5); 
		;
	\end{tikzpicture}
\end{figure}
		With each $(\ell_i, \ell_{i + 1}) \in \Delta$, $\varphi_i$ being the formula of transformula $\psi_i$, where $st(\psi_i) = (\ell_i, \ell_{i + 1})$.
		\item[2.] Prove feasibility. \\ In case that the trace is proven feasible, the program is incorrect, if the trace is infeasible construct an infeasibility proof.
		\item[3.] Use the infeasibility proof to calculate interpolants.
		\item[4.] Construct an automaton, $\mathcal{A}_i$, from the interpolants.
		\item[5.] If the language $\mathcal{L(A_P)}$, that is recognized by the program's control-flow graph, is a subset of the union of languages recognized by the constructed automata: $\mathcal{L(A_P)} \subseteq \mathcal{L(A}_1) \cup ... \cup \mathcal{L(A}_i)$ then the program is correct, else start again at step 1.
	\end{itemize}
	The interpolants generated in step 3 serve to generalize the infeasibility proof to exclude other possible error traces. However, the interpolants are not guaranteed to be general enough to exclude a large number of error traces. Which poses a problem for loops. In the following we introduce a way to exclude a large number of traces going through a loop.


\section{Loop Acceleration}
Programs generally contain loops, like \texttt{while} or \texttt{for} loops. These can create up to infinitely many distinct program traces. Trace abstraction has then, in the worst case, meaning the generated Craig interpolants are only general enough to disprove one trace, refute every program trace generated by the loop. A remedy to that is by computing a loop acceleration in form of the reflexive transitive closure. This chapter introduces loops as traces and relations, and how a loop relation can be used to compute a reflexive transitive closure. \\

Assume we are given the following program trace $\tau$ from the example program $P$:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=3cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=2}
		initial text =]
		
		\node[state](1){$\ell_0$};
		\node[state] (2) [right of=1] {$\ell_1$};
		\node[state] (3) [right of=2] {$\ell_2$};
		\node[state] (4) [right of=3] {$\ell_1$};
		\node[state] (5) [right of=4] {$\ell_2$};
		\node[state] (6) [below of=1] {$\ell_1$};
		\node[state] (7) [right of=6] {$\ell_2$};
		\node[state] (8) [right of=7] {$\ell_1$};
		\node[state] (9) [right of=8] {$\ell_3$};
		\node[state] (10) [right of=9] {$\ell_E$};
		
		
		\path (1) edge node {$x_0 = 0$} (2);
		\path (2) edge node {$x_0 < 6$} (3);
		\path (3) edge node {$x_1 = x_0 + 2$} (4);
		\path (4) edge node {$x_1 < 6$} (5);
		\path (5) edge node {$x_2 = x_1 + 2$} (6);
		\path (6) edge node[below] {$x_2 < 6$} (7);
		\path (7) edge node[below] {$x_3 = x_2 + 2$} (8);
		\path (8) edge node[below] {$x_3 \geq 6$} (9);
		\path (9) edge node[below] {$x_3 \neq 6$} (10);
		;
	\end{tikzpicture}
	\captionof{figure}{$\tau$}
\end{figure}
It is noticeable that program location $\ell_1$ appears repeatedly in the trace, indicating that it is an entry point for a loop. From this entry point, the so called loophead, one can extract a loop trace. 
\begin{mydef}
	A loop trace $\tau_L$ is a program trace  $\psi_0, \psi_1, \ldots,  \psi_{n - 1}, \psi_n$, where \\ $st(\psi_0) = (\ell_0, \ell_1)$ and $(\ell_{n - 1}, \ell_0) = st(\psi_n)$. $\ell_0$ is called the loophead.
\end{mydef}

In $\tau$ there are three loop traces of varying length:  \\

\begin{figure}[H]
	\centering
		\begin{tikzpicture}[%
			->,
			>=stealth', shorten >=1pt, auto,
			node distance=3cm, scale=1, 
			transform shape, align=center,    
			smallnode/.style={inner sep=2}
			initial text =]
			
			\node[state] (2) [] {$\ell_1$};
			\node[state] (3) [right of=2] {$\ell_2$};
			\node[state] (4) [right of=3] {$\ell_1$};
			
			\path (2) edge node {$x_0 < 6$} (3);
			\path (3) edge node {$x_1 = x_0 + 2$} (4);
			;
		\end{tikzpicture}
		\captionof{figure}{$\tau_{L_1}$}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=3cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=2}
		initial text =]
		
		\node[state] (2) [] {$\ell_1$};
		\node[state] (3) [right of=2] {$\ell_2$};
		\node[state] (4) [right of=3] {$\ell_1$};
		\node[state] (5) [right of=4] {$\ell_2$};
		\node[state] (6) [right of=5] {$\ell_1$};
		
		\path (2) edge node {$x_0 < 6$} (3); 
		\path (3) edge node {$x_1 = x_0 + 2$} (4);
		\path (4) edge node {$x_1 < 6$} (5);
		\path (5) edge node {$x_2 = x_1 + 2$} (6);
		;
	\end{tikzpicture}
	\captionof{figure}{$\tau_{L_2}$}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=3cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=2}
		initial text =]
		
		\node[state] (2) [] {$\ell_1$};
		\node[state] (3) [right of=2] {$\ell_2$};
		\node[state] (4) [right of=3] {$\ell_1$};
		\node[state] (5) [right of=4] {$\ell_2$};
		\node[state] (6) [right of=5] {$\ell_1$};
		\node[state] (7) [below right=2cm and 4cm of 2] {$\ell_2$};
		\node[state] (8) [right of=7] {$\ell_1$};
		
		\path (2) edge node {$x_0 < 6$} (3);
		\path (3) edge node {$x_1 = x_0 + 2$} (4);
		\path (4) edge node {$x_1 < 6$} (5);
		\path (5) edge node {$x_2 = x_1 + 2$} (6);
		\path (6) edge node[below right] {$x_2 < 6$} (7);
		\path (7) edge node[below] {$x_3 = x_2 + 2$} (8);
		;
	\end{tikzpicture}
	\captionof{figure}{$\tau_{L_3}$}
\end{figure}
These three looping traces represent the same loop but with a different number of iterations. The loop relation can be represented solely by $\tau_{L_1}$.
\begin{mydef}
	A minimal loop trace $\tau_{min}$ is a loop trace \\ $\psi_0, \psi_1, \ldots,  \psi_{n - 1}$, where $\ell_0$ only appears as first and last location. It represents one iteration of the loop.
\end{mydef}
In this example $\tau_{L_1}$ is the minimal loop trace. \\

Using the minimal looping trace it is possible to formulate the overall effect the loop has on the program state.
\begin{mydef}
	The loop relation $\psi_L$ describes the effect of loop $L$ on the program state as a transformula.
	Given the minimal looping trace $\tau_{min}: \psi_0, \psi_1, \ldots, \psi_{n}$ the loop relation can be constructed by building the composition of all $\psi_i$.
	$\psi_L = \psi_0 \circ \psi_1 \circ \cdots \circ \psi_n$
\end{mydef}
For $\tau_{L_1}$ the loop relation is $x_0 < 6 \land x_1 = x_0 + 2$ \\
The loop relation can appear in a program trace a possibly infinite amount of times, leading to infinitely many program traces. \\
It is however possible to contain every program trace going through a loop in a single transformula, the so called reflexive transitive closure.
\begin{mydef}
	Given loop relation $R_L$, the reflexive transitive closure $R^*$ is a relation that includes every possible loop trace from every possible loop iteration. It is defined as follows:
	\begin{itemize}
		\item $\psi^* = \bigvee_{i=0}^\infty \psi^i$
		\item $\psi^i = $
		$\begin{cases}
			& \varepsilon \hspace{1.5cm} \text{if}\ i = 0 \\
			& \psi \circ \psi^{i - 1} \hspace{0.5cm}\text{otherwise}
		\end{cases}$
	\end{itemize}
\end{mydef}
This reflexive transitive closure will be used in the following chapter to compute more general interpolants for trace abstraction.

\section{Accelerated Interpolation}
This section will introduce the technique of combining loop acceleration and interpolating trace abstraction. 
To check the reachability of $\ell_E$ we use the trace abstraction paradigm: \\
Firstly, we need a possible error trace $\tau_0$. \\ \\

\begin{figure}[H]
\begin{tikzpicture}[%
->,
>=stealth', shorten >=1pt, auto,
node distance=2.5cm, scale=1, 
transform shape, align=center,    
smallnode/.style={inner sep=1.4}
initial text =]

\node[state](1){$\ell_0$};

\node[state] (2) [right of=1] {$\ell_1$};

\node[state] (3) [right of=2] {$\ell_2$};

\node[state] (4) [right of=3, xshift=1cm] {$\ell_1$};

\node[state] (5) [right of=4] {$\ell_3$};

\node[state] (6) [right of=5] {$\ell_E$};

\path (1) edge node {$x_0 = 0$} (2); \\
\path (2) edge node {$x_0 < 6$} (3); \\
\path (3) edge node {$x_1 = x_0 + 2$} (4);\\
\path (4) edge node {$x_1 \geq 6$} (5); \\
\path (5) edge node {$x_1 \neq 6$} (6); \\
;
\end{tikzpicture}
	\captionof{figure}{$\tau_0$}
\end{figure}

\subsection{Meta-Traces}
The transitive closure of a loop contains every trace going through it. To make use of loop acceleration, we need to pull apart the looping location $\ell_2$ by introducing so called meta-transitions of the form:
\begin{equation*}
\overset{stm_3\ \circ \ stm_4}{\overset{\curvearrowright}{\ell_2}} \Rightarrow \hspace*{1cm} \ell_2' \xrightarrow{\text{$(stm_3 \circ stm_4)^*$}} \ell_2''
\end{equation*}
Where $(stm_3 \circ stm_4)^*$ symbolizes the calculated transitive closure of the loop. \par
Using meta-transitions, we can transform our trace scheme into a meta-trace:
\begin{equation*}
\bar{\tau}: \ell_0 \xrightarrow{\text{$stm_1$}} \ell_1 \xrightarrow{\text{$stm_2$}} \ell_2' \xrightarrow{\text{$(stm_3 \circ stm_4)^*$}} \ell_2'' \xrightarrow{\text{$stm_5$}} \ell_E
\end{equation*}
The feasibility of the meta-trace is the same as the trace scheme before: \\
\begin{itemize}
	\item  If it is feasible then the original trace is feasible, making the program incorrect
	\item If it is infeasible, we can compute an interpolant sequence: \\
	\begin{equation*}
	I_{\bar{\tau}}: \langle \top, I_1, I_2', I_2'', \bot  \rangle
	\end{equation*}
\end{itemize}

To guarantee inductiveness to the loop, we have to compute the strongest post of each interpolant, that coincide with a location in the loop, and its transitive closure:
\begin{equation*}
I_{\bar{\tau}}^{post}: \langle \top, I_1, post(I_2', stm_3 \circ stm_4), \bot  \rangle
\end{equation*}
This sequence is now general enough for the trace scheme to exclude the loop.

\subsection{Branching Loops}

\section{Accelerated Interpolation in Ultimate}
\subsection{Loopdetector}
\subsubsection{Simple Loops}

\subsubsection{Nested Loops}

\subsubsection{Procedures}

\subsection{Looppreprocessor}

\subsection{Accelerated Interpolation}


\section{Experimental Results}

\section{Future Work}
\jw{More Acceleration methods}

\pagebreak
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain}
\bibliography{bib}

	
\end{document}