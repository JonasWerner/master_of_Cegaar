\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{xspace}
\usepackage{tabu}
\usepackage[%
  hyperindex,%
  plainpages=false,%
  pdfusetitle]{hyperref}
\usepackage[all]{hypcap}
\usepackage{cite}
\usepackage{booktabs}
\usepackage{url}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{tikz}
\usetikzlibrary{positioning,shapes.geometric, arrows,automata, decorations.pathreplacing, calc}
\usepackage{pgf}
\usepackage{slantsc}
\usepackage{geometry}
\usepackage{amssymb}
\usepackage{subcaption}
\usepackage{float}
\usepackage{pgf}
\usepackage{slashbox}
\usepackage{pgfgantt}
\usepackage{wrapfig}
\usepackage{pdflscape}

	

\newcommand{\tf}{\ensuremath{\varphi}\xspace}
\newcommand{\ctf}{\ensuremath{\widehat{\varphi}}\xspace}
\newcommand{\invars}{\ensuremath{In}\xspace}
\newcommand{\outvars}{\ensuremath{Out}\xspace}
\newcommand{\auxvars}{\ensuremath{Aux}\xspace}

\newcommand{\WidestEntry}{$\psi_{global}$}%
\newcommand{\SetToWidest}[1]{\makebox[\widthof{\WidestEntry}]{$#1$}}%


\usepackage[%disable,%
  colorinlistoftodos,%
  color=cyan!50!white,%
  bordercolor=cyan!50!black]{todonotes}

%%%%%%%%%%%% Colors 
%% a somewhat friendly scheme for 5 different colors 
\definecolor{g1}		{RGB}{215,25,28} % a kind of red
\definecolor{g2}		{RGB}{253,174,97} % a kind of orange
\definecolor{g3}		{RGB}{255,255,191} % a kind of yellow
\definecolor{g4}		{RGB}{171,217,233} % a kind of light blue 
\definecolor{g5}		{RGB}{44,123,182} % a kind of dark blue 

\definecolor{gr1}		{RGB}{250, 250, 250}
\definecolor{gr2}		{RGB}{229, 229, 229} % some grey

% color of interpolants
\definecolor{grey}{RGB}{200,200,200}

%color for pictures
\colorlet{outlineblue}		{g5}
\colorlet{fillblue}			{g4}
\colorlet{darkback}			{gr2}
\colorlet{lightback}		{gr1}
\colorlet{stmtcolor}		{gr2} %default statement color
\colorlet{subgraphcolor}	{g3} %default statement color


%%%%%%%%%%%% Setup
\newtheorem{name}{Printed output}
\newtheorem{mydef}{Definition}

\hypersetup{
colorlinks=true,        % false: boxed links; true: colored links
linkcolor=g1,        % color of internal links
citecolor=g1,        % color of links to bibliography
filecolor=g1,        % color of file links
urlcolor=g1          % color of external links
}


\lstdefinestyle{boogie}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  numbers=left,
  xleftmargin=.6cm
}

\lstset{escapechar=@,style=boogie}

%%%%%%%%%%%% Comments
\newif\iffinal
%\finaltrue % comment out to remove comments 
 
\iffinal
\newcommand\mycom[1]{}
\else
\newcommand\mycom[1]{#1}
\overfullrule=1mm
\fi
\setlength\parindent{0pt}

\newcommand{\jw}[1]{\mycom{\todo[color=blue!40,inline]{\small JW: #1}}}
\newcommand{\dd}[1]{\mycom{\todo[color=orange!40,inline]{\small DD: #1}}}
\newcommand{\ts}[1]{\mycom{\todo[color=green!40,inline]{\small TS: #1}}}


\newcommand{\all}[1]{\mycom{\todo[color=green!40,inline]{\small #1}}}
\newcommand{\meta}[1]{\mycom{\todo[color=blue!10,inline,caption={Beschreibung},nolist]{\setlist{nolistsep}\small #1}}}
\newcommand{\xxx}{\mycom{\stfootcol{Placeholder}{blue!20}\xspace}}
\newcommand{\cn}{\mycom{\stfootcol{Cite}{blue!20}\xspace}}


\begin{document}
	\newcommand{\HorizontalLine}{\rule{\linewidth}{0.3mm}}
	
		\begin{center}
		{\scshape\Large Master Project \par}
		\vspace{1.5cm}
		{\huge\bfseries Accelerated Interpolation \par}
		\vspace{1cm}
		{\large \scshape Jonas Werner\par}
		\vspace{0.5cm}
		{\today \vspace{2cm}} 
		
		\end{center}

\section{Introduction}
Assume we are given a program $P$ and a safety property and want to verify whether $P$ fulfils this property. $P$ consists of a set of program statements, like assignments: \texttt{x := 0}, or assumptions: \texttt{x != 42}, these program statements form a finite alphabet $\Sigma$. A program trace is a sequence of program statements, or a word over $\Sigma$. \\
A program can be represented as a directed labelled graph, called control-flow graph, with program locations as nodes and edges labelled with program statements, with a distinct initial location. The control-flow graph depicts all possible transitions from one program location to another. An error location is a program location, that violates the safety property. The goal is to check whether there is a program trace, called error trace, that starts in the initial node and ends in the error location, that is feasible. 

Trace abstraction aims at constructing automata \cite{10.1007/978-3-642-39799-8_2} from infeasible error traces. When the language recognized by the program's control-flow graph is a subset of these automata, it means, every possible error trace, and by that execution which ends in an error location, is infeasible. Proving that the program fulfills the safety property. If there is a single feasible error trace, then the program violates the safety property.\\
\par 
If an error trace is infeasible there is an infeasibility proof. Using this proof one can construct an automaton, which excludes the original error trace from the control-flow graph. However, this excludes only one error trace, making this approach not very efficient. To exclude more than one error trace, one can try to compute a generalization of the infeasibility proof. \par

A common strategy is \cite{10.1007/978-3-642-03237-0_7} to calculate a generalization using Craig interpolation \cite{craig_1957}, where an SMT-solver computes a sequence of interpolants from an infeasibility proof. \par 
But, it is not guaranteed that these interpolants are more general. This issue is most notably in program loops. Assume that the given program contains a loop with guard $x < 5000$, $x$ being an integer variable. It is possible that the computed interpolant sequence does not exclude every loop iteration, leading to the need of disproving every of the 5000 possible error traces individually. \\ \\
A solution for this problem is accelerating the loop, meaning computing its transitive closure, and calculating interpolants on that. \par This project aims at implementing exactly that. 
The goal is to combine interpolation and loop acceleration on the basis of the work of Hojjat et al \cite{10.1007/978-3-642-33386-6_16} in the software analysis framework \\ Ultimate \cite{Zitat02}. \par
The remainder of this proposal is structured as follows. Chapter 2 will give an overview of needed background information, like a more detailed look at trace abstraction, loop acceleration, and the combination of interpolation and acceleration. Chapter 3 will detail the approach this project will take to implement accelerated interpolation in Ultimate, and finally an outline of the project's deliverables and schedule.

\section{Background}
This project aims at combining loop acceleration and interpolant calculation, based on the findings of Hojjat et al. \cite{10.1007/978-3-642-33386-6_16}, however, instead of utilizing a CEGAR-scheme with predicate abstraction, it was be implemented as an automata-based CEGAR-scheme, called trace abstraction. \par
This section will introduce the basic ideas behind trace abstraction, loop acceleration, and finally accelerated interpolants.

\subsection{Programs}
Assume we are given a program and want to verify its safety by checking reachability of an error location. 
To apply interpolating trace abstraction one firstly needs to know what a program is. 
We use definitions from \jw{citation needed Refining trace abstraction)}

In this paper, we consider a programming language consisting of the basic program statements assignment, assume, and sequential composition. Its syntax is denoted by the following grammar:
\begin{equation*}
	\texttt{s := assume bexpr | x := expr | s;s}
\end{equation*}
Where, given a finite set of program variables $Var$, \texttt{expr} is an expression over $Var$ and \texttt{bexpr} is a Boolean expression over $Var$. For brevity's sake we use \texttt{bexpr} instead of \texttt{assume bexpr}.
Using this programming language, it is possible to represent a program as follows.
\begin{mydef}
	A program $P$ over a given set of statements $Stmt$ can be represented as a labeled graph, called control-flow graph, $G_P = (Loc, \delta, \ell_{init}, \ell_{err})$, with $Loc$ being a finite set of program locations, a set of edges between two program locations labeled with a statement $\delta \subseteq Loc \times Stmt \times Loc$, an initial location $\ell_0 \in Loc$, and an error location $\ell_{err} \in Loc$.
\end{mydef}

Consider for example the following program $P_0$:
\begin{figure}[H]
	\begin{align*}
		&\texttt{1: int x := 0}; \\
		&\texttt{2: while x < 6:} \\
		&\texttt{3: \hspace*{2em} x := x + 2;} \\
		&\texttt{4: end while} \\
		&\texttt{5: assert x == 6;}
	\end{align*}
	\captionof{figure}{Example Program $P_0$.}
	\label{fig:square}
\end{figure}

$P_0$ is defined over the set of program statements: 
\begin{equation*}
	\Sigma = (\texttt{x := 0},\texttt{x < 6}, \texttt{x := x + 2}, \texttt{assume !x < 6}, \texttt{x == 6}, \texttt{x != 6})
\end{equation*} 
That form an alphabet. \\ \par
The program can be presented as control-flow graph $G_{P_0} = (Loc_P, \delta_P, \ell_{init}, \ell_{err})$, with 
\begin{itemize}
	\item $Loc_P = \{ \ell_1, \ell_2, \ell_3, \ell_4, \ell_5, \ell_6 \}$
	\item $\begin{aligned}[t]	\delta_P = \{ &(\ell_1,\ \texttt{x := 0},\ \ell_2), (\ell_2,\ \texttt{ x < 6},\ \ell_3), (\ell_3,\ \texttt{x := x + 2},\ \ell_2), \\ &(\ell_2,\ \texttt{!x < 6},\ \ell_4), (\ell_4,\ \texttt{x == 6},\ \ell_5), (\ell_4,\ \texttt{x != 6},\ \ell_6)\} \end{aligned}$
	\item  $\ell_{init} = \ell_1$
	\item $\ell_{err} = \ell_6$
\end{itemize}
And the following graphical representation: 

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=3cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=1.4}
		initial text =]
		\node[state, initial above](1){$\ell_1$};
		
		\node[state] (2) [below of=1] {$\ell_2$};
		
		\node[state] (3) [left of=2] {$\ell_3$};
		
		\node[state] (4) [right of=2] {$\ell_4$};
		
		\node[state] (5) [below of=4] {$\ell_5$};
		
		\node[state] (6) [right of=4] {$\ell_6$};
		
		\path (1) edge node {\texttt{x := 0}} (2)
		(2) edge [bend right] node [above]{\texttt{x < 6}} (3)
		(3) edge [bend right] node [below]{\texttt{x := x + 2}} (2)
		(2) edge node {\texttt{!x < 6}} (4)
		(4) edge node {\texttt{x == 6}} (5)
		(4) edge node {\texttt{x != 6}} (6)
		;
	\end{tikzpicture}
	\captionof{figure}{Control-Flow Graph $G_{P_0}$ of Program $P_0$.}
	\label{fig:rect}
\end{figure}
Each program variable has a domain $D$ defining the set of all possible values.
\begin{mydef}
	A variable valuation of a program variable $v \in Var$ is a function $\rho: v \rightarrow D$  assigning it a value from its domain.
\end{mydef}
Assigning every program variable a valuation creates a program state.

%the n may be wrong, because traces can be infinite in theory?

\begin{mydef}
	Assume a program $P$ is defined over $n$ variables, a program state $\sigma$ is a function assigning each variable $v_i \in V$, \ $0 \leq i \leq n$ a variable valuation $\rho_i$. The set $S$ denotes the set of all program states.
\end{mydef}

Program statements can change the valuation of variables, transitioning one program state to another.

\begin{mydef}
	Each program statement $\texttt{s} \in Stmt$ defines a binary relation $\rho_s \subseteq S \times S$ over the set of program states $S$, called successor relation. Which is, given an interpretation function $\mathcal{I}$, inductively defined as \\
\end{mydef}
	 $ \rho_s =
\begin{cases}
	\{(\sigma, \sigma')\ |\ \mathcal{I}(\text{bexpr})(\sigma)\ =\ true\ \text{and}\ \sigma = \sigma'\} , & \text{if}\ s \equiv \text{\texttt{assume bexpr}} \\
	\{(\sigma, \sigma')\ |\ \sigma' = \sigma[x \mapsto \mathcal{I}(expr)(\sigma)]\} , & \text{if}\ s \equiv \texttt{x := expr} \\
	\{(\sigma, \sigma')\ |\ \exists \sigma''\ \text{where}\ (\sigma, \sigma'') \in \rho_{s_1}\ \text{and}\ (\sigma'', \sigma') \in \rho_{s_2} \}, & \text{if}\ s \equiv \texttt{$s_1;s_2$}
\end{cases}
$
\vspace{0.7cm} \\ 
Programs model multiple program statement sequences:
\begin{mydef}
Given a program $P = (Loc, \delta, \ell_{init}, \ell_{err})$ that is defined over a set of program statements $Stmt$, and its control-flow graph $G_P$, we call a sequence of program statements $\tau: s_0, s_1, s_2, ..., s_n \in Stmt^*$ a program trace, if $\tau$ is the labeling of a path starting in $\ell_{init}$. Meaning, each for each $s_i$, $0 \leq i \leq n$, there is $(\ell_i, s_i, \ell_{i+1}) \in \delta$. The program trace is called error trace if $\ell_n = \ell_{err}$.  
\end{mydef}

For example, consider program $P_0$ from before. A possible error trace would be:
\begin{equation*}
	\tau_0:\ \ \texttt{x := 0},\ \texttt{x < 6},\ \texttt{x := x + 2},\ \texttt{!x < 6},\ \texttt{x != 6}
\end{equation*}
Graphically represented as:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=2.5cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=2}
		initial text =]
		
		\node[state] (2) {$\ell_1$};
		
		\node[state] (3) [right of=2] {$\ell_2$};
		
		\node[state] (4) [right of=3] {$\ell_3$};
		
		\node[state] (5) [right=3cm of 4] {$\ell_2$};
		
		\node[state] (6) [right of=5] {$\ell_4$};
		
		\node[state] (7) [right of=6] {$\ell_6$};
		
		
		\path (2) edge node {\texttt{x := 0}} (3); 
		\path (3) edge node {\texttt{x < 6}} (4); 
		\path (4) edge node {\texttt{x := x + 2}} (5); 
		\path (5) edge node {\texttt{!x < 6}} (6);
		\path (6) edge node {\texttt{ x != 6}} (7); 
		;
	\end{tikzpicture}
\end{figure}

Because a program trace is rather abstract, the question arises whether the program can actually take the defined sequence of statements.

\begin{mydef}
	Given a program $P = (Loc, \delta, \ell_{init}, \ell_{err})$ and a program trace $\tau:\ s_0, s_1, s_2, ..., s_n$ of $P$, a sequence of program states $\pi:\ \sigma_0, \sigma_1, \sigma_2,..., \sigma_n$ is a program execution of $\tau$, if $(\sigma_i, \sigma_{i+1} \in \rho _{s_i})$ for $0 \leq i \leq n$. \\
	Trace $\tau$ is called feasible if there is a corresponding program execution, otherwise it is infeasible.
\end{mydef}

$\tau_0$ from before is infeasible, because for $\texttt{assume !x < 6}$, the interpretation function $\mathcal{I}(\texttt{!x < 6})(x = 2)$ evaluates to false and is, with that, not part of the successor relation.
%Are there annotations of the nodes correct?
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=2.5cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=2}
		initial text =]
		
		\node[state, label=above:{$true$}] (2) {$\ell_1$};
		
		\node[state, label=above:{$x = 0$}] (3) [right of=2] {$\ell_2$};
		
		\node[state, label=above: {$x = 0$}] (4) [right of=3] {$\ell_3$};
		
		\node[state, label=above:{$x = 2$}] (5) [right=3cm of 4] {$\ell_2$};
		
		\node[state, label=above:{$false$}] (6) [right of=5] {$\ell_4$};
		
		\node[state, label=above:{$false$}] (7) [right of=6] {$\ell_6$};
		
		
		\path (2) edge node {\texttt{x := 0}} (3); 
		\path (3) edge node {\texttt{x < 6}} (4); 
		\path (4) edge node {\texttt{x := x + 2}} (5); 
		\path (5) edge node {\texttt{!x < 6}} (6);
		\path (6) edge node {\texttt{ x != 6}} (7); 
		;
	\end{tikzpicture}
\end{figure}

Program trace $\tau_0$ will therefore never occur in $P_0$. \\

\begin{mydef}
	Given a program trace $\tau: s_0, s_1, ..., s_n$ a sequence of program states $\pi: \sigma_0, \sigma_1, ..., \sigma_n$ is called an inductive sequence of states for $\tau$ if the strongest postcondition of every program state $\sigma_i$ under the program statement $st_{i+1}$ implies the follow up state $\sigma_{i+1}$. 
	\begin{equation*}
			sp(\sigma_i, st_{i+1}) \implies \sigma_{i+1}
	\end{equation*}
\end{mydef}
The sequence of program states $\pi_0: true, x = 0, x = 0, x = 2, false, false$ is an inductive sequence of program states for $\tau_0$

\begin{mydef}
	An inductive sequence of program states $\pi: \sigma_0, \sigma_1,..., \sigma_n$ of program trace $\tau$ is a proof of infeasibility for $\tau$ if $\sigma_0 = true$ and $\sigma_n = false$.
\end{mydef}
A proof of infeasibility refutes the possibility of a program trace being taken. The goal of


\vspace{5cm}

\jw{Todo Interpolants as generalization}
For example, consider the conjunction:
\begin{equation}
	x_0 = 5 \land x_0 \leq 3
\end{equation}
Which is unsatisfiable. A derived interpolant is $x_0 = 5$ \\
	Interpolanten -> Sequenzinterpolanten \cite{10.1007/11691372_33}-> Interpolantenautomat

\vspace*{2cm}

\subsection{Interpolating Trace Abstraction}

By combining infeasibility proofs and interpolant computation we can define trace abstraction as a technique for proving or disproving safety for a given program by checking for reachability of an error location.
Given a program $P = (Loc, \delta, \ell_{init}, \ell_{err})$ and its control-flow graph $G_P$, to check reachability of error location $\ell_{err}$, use trace abstraction with interpolation according to the following paradigm \cite{10.1007/978-3-642-03237-0_7}: \\
\begin{itemize}
	\item[1.] Search $G_P$ for a program trace that starts at $\ell_{init}$ and ends in $\ell_{err}$:
	\begin{figure}[H]
		\centering
		\begin{tikzpicture}[%
			->,
			>=stealth', shorten >=1pt, auto,
			node distance=2.5cm, scale=1, 
			transform shape, align=center,    
			smallnode/.style={inner sep=2}
			initial text =]
			
			\node[state](1){$\ell_{init}$};
			
			\node[state] (2) [right of=1] {$\ell_1$};
			
			\node[] (3) [right of=2] {$\cdots$};
			
			\node[state] (4) [right of=3] {$\ell_{n-1}$};
			
			\node[state] (5) [right of=4] {$\ell_{err}$};
			
			
			\path (1) edge node {\texttt{$s_0$}} (2); 
			\path (2) edge node {$s_1$} (3); 
			\path (3) edge node {$s_{n-1}$} (4);
			\path (4) edge node {$s_n$} (5); 
			;
		\end{tikzpicture}
	\end{figure}
		\item[2.] Prove feasibility. \\ In case that the trace is proven feasible, the program is incorrect, if the trace is infeasible construct an infeasibility proof.
		\item[3.] Use the infeasibility proof to calculate interpolants.
		\item[4.] Construct an automaton, $\mathcal{A}_i$, from the interpolants.
		\item[5.] If the language $\mathcal{L(A_P)}$, that is recognized by the program's control-flow graph, is a subset of the union of languages recognized by the constructed automata: $\mathcal{L(A_P)} \subseteq \mathcal{L(A}_1) \cup ... \cup \mathcal{L(A}_i)$ then the program is correct, else start again at step 1.
	\end{itemize}
	The interpolants generated in step 3 serve to generalize the infeasibility proof to exclude other possible error traces. However, the interpolants are not guaranteed to be general enough to exclude a large number of error traces. Which poses a problem for loops. In the following we introduce a way to exclude a large number of traces going through a loop.


\section{Loop Acceleration}
Programs generally contain loops, like \texttt{while} or \texttt{for} loops. These can create up to infinitely many distinct program traces. Trace abstraction has then, in the worst case when the generated Craig interpolants are only general enough to disprove one trace, refute every program trace generated by the loop. A remedy to that is the computation of a loop acceleration in form of the reflexive transitive closure. This chapter introduces loops as traces and relations, and how a loop relation can be used to compute a reflexive transitive closure. \\

Assume we are given the following program $P_1$: \\
\begin{figure}[H]
	\begin{align*}
		&\texttt{1: int x := 0}; \\
		&\texttt{2: int y := 42}; \\
		&\texttt{3: while x <= 200:} \\
		&\texttt{4: \hspace*{2em} x := x + 2;} \\
		&\texttt{5: \hspace*{2em} y := x + 5;} \\
		&\texttt{6: end while} \\
		&\texttt{7: assert y == 207;}
	\end{align*}
	\captionof{figure}{Example Program $P_0$.}
	\label{fig:square}
\end{figure}
With its control-flow graph $G_{P_1}$: \\
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=3cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=1.4}
		initial text =]
		
		\node[state, initial above](1){$\ell_1$};
		
		\node[state] (2) [below of=1] {$\ell_2$};
		
		\node[state] (7) [below of=2] {$\ell_3$};
		
		\node[state] (3) [left of=7] {$\ell_4$};
		
		\node[state] (8) [below of=3] {$\ell_5$};
		
		\node[state] (4) [right of=7] {$\ell_6$};
		
		\node[state] (5) [below of=4] {$\ell_7$};
		
		\node[state] (6) [right of=4] {$\ell_8$};
		
		\path (1) edge node {\texttt{x := 0}} (2)
		(2) edge node {\texttt{y := 42}} (7)
		(7) edge node[above] {\texttt{x <= 200}} (3)
		(3) edge node[left=0.25cm] {\texttt{x := x + 2}} (8)
		(8) edge node[right=0.25cm] {\texttt{y := x + 5}} (7)
		(7) edge node {\texttt{!x <= 200}} (4)
		(4) edge node {\texttt{y == 207}} (5)
		(4) edge node {\texttt{y != 207}} (6)
		;
	\end{tikzpicture}
	\captionof{figure}{Control-Flow Graph $G_{P_1}$ of Program $P_1$.}
	\label{fig:rect}
\end{figure}
Assume trace abstraction generates program trace $\tau_1$:
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=3.25cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=2}
		initial text =]
		
		\node[state](1){$\ell_1$};
		\node[state] (2) [right of=1] {$\ell_2$};
		\node[state] (3) [right of=2] {$\ell_3$};
		\node[state] (4) [right of=3] {$\ell_4$};
		\node[state] (5) [right of=4] {$\ell_5$};
		\node[state] (6) [below of=1] {$\ell_3$};
		\node[state] (7) [right of=6] {$\ell_4$};
		\node[state] (8) [right of=7] {$\ell_5$};
		\node[state] (9) [right of=8] {$\ell_3$};
		\node[state] (10) [right of=9] {$\ell_4$};
		\node[state] (11) [below of=6] {$\ell_5$};
		\node[state] (12) [right of=11] {$\ell_3$};
		\node[state] (13) [right of=12] {$\ell_6$};
		\node[state] (14) [right of=13] {$\ell_7$};
		
		
		\path (1) edge node {\texttt{x := 0}} (2);
		\path (2) edge node {\texttt{y := 42}} (3);
		\path (3) edge node {\texttt{x <= 200}} (4);
		\path (4) edge node {\texttt{x := x + 2}} (5);
		\path (5) edge node {\texttt{y := x + 5}} (6);
		\path (6) edge node[below] {\texttt{x <= 200}} (7);
		\path (7) edge node[below] {\texttt{x := x + 2}} (8);
		\path (8) edge node[below] {\texttt{y := x + 5}} (9);
		\path (9) edge node {\texttt{x <= 200}} (10);
		\path (10) edge node {\texttt{x := x + 2}} (11);
		\path (11) edge node[below] {\texttt{y := x + 5}} (12);
		\path (12) edge node[below] {\texttt{!x <= 200}} (13);
		\path (13) edge node[below] {\texttt{y != 207}} (14);
		;
	\end{tikzpicture}
	\captionof{figure}{Program Trace $\tau_1$ of $P_1$}
\end{figure}
It is noticeable that program location $\ell_3$ appears repeatedly in the trace indicating that it is an entry point for a loop. From this entry point, the so called loophead, one can extract a loop trace. 
\begin{mydef}
	A loop trace $\tau_L$ is a program trace  $s_0, s_1, \ldots, s_n$, where $s_0 = s_n$.
\end{mydef}

In $\tau_1$ there are three loop traces of varying length:  \\

\begin{figure}[H]
	\centering
		\begin{tikzpicture}[%
			->,
			>=stealth', shorten >=1pt, auto,
			node distance=3cm, scale=1, 
			transform shape, align=center,    
			smallnode/.style={inner sep=2}
			initial text =]
			
			\node[state] (2) [] {$\ell_3$};
			\node[state] (3) [right of=2] {$\ell_4$};
			\node[state] (4) [right of=3] {$\ell_5$};
			\node[state] (5) [right of=4] {$\ell_3$};
			
			\path (2) edge node {\texttt{x <= 200}} (3);
			\path (3) edge node {\texttt{x = x + 2}} (4);
			\path (4) edge node {\texttt{y = x + 5}} (5);
			;
		\end{tikzpicture}
		\captionof{figure}{Loop Trace $\tau_{L_1}$}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=3cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=2}
		initial text =]
		
		\node[state] (2) [] {$\ell_3$};
		\node[state] (3) [right of=2] {$\ell_4$};
		\node[state] (4) [right of=3] {$\ell_5$};
		\node[state] (5) [right of=4] {$\ell_3$};
		\node[state] (6) [below of=2] {$\ell_4$};
		\node[state] (7) [right of=6] {$\ell_5$};
		\node[state] (8) [right of=7] {$\ell_3$};
		
		\path (2) edge node {\texttt{x <= 200}} (3);
		\path (3) edge node {\texttt{x = x + 2}} (4);
		\path (4) edge node {\texttt{y = x + 5}} (5);
		\path (5) edge node {\texttt{x <= 200}} (6);
		\path (6) edge node[below] {\texttt{x = x + 2}} (7);
		\path (7) edge node[below] {\texttt{y = x + 5}} (8);
		;
	\end{tikzpicture}
	\captionof{figure}{Loop Trace $\tau_{L_2}$}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=3cm, scale=1, 
		transform shape, align=center,    
		smallnode/.style={inner sep=2}
		initial text =]
		
		\node[state] (2) [] {$\ell_3$};
		\node[state] (3) [right of=2] {$\ell_4$};
		\node[state] (4) [right of=3] {$\ell_5$};
		\node[state] (5) [right of=4] {$\ell_3$};
		\node[state] (6) [below of=2] {$\ell_4$};
		\node[state] (7) [right of=6] {$\ell_5$};
		\node[state] (8) [right of=7] {$\ell_3$};
		\node[state] (9) [right of=8] {$\ell_4$};
		\node[state] (10) [below of=6] {$\ell_5$};
		\node[state] (11) [right of=10] {$\ell_3$};
		
		\path (2) edge node {\texttt{x <= 200}} (3);
		\path (3) edge node {\texttt{x = x + 2}} (4);
		\path (4) edge node {\texttt{y = x + 5}} (5);
		\path (5) edge node {\texttt{x <= 200}} (6);
		\path (6) edge node[below] {\texttt{x = x + 2}} (7);
		\path (7) edge node[below] {\texttt{y = x + 5}} (8);
		\path (8) edge node {\texttt{x <= 200}} (9);
		\path (9) edge node {\texttt{x = x + 2}} (10);
		\path (10) edge node[below] {\texttt{y = x + 5}} (11);
		;
	\end{tikzpicture}
	\captionof{figure}{Loop Trace $\tau_{L_3}$}
\end{figure}
These three looping traces represent the same loop but with a different number of iterations.
\begin{mydef}
	A minimal loop trace $\tau_{min}$ is a loop trace $s_0, s_1, \ldots, s_n$, where the loophead $\ell_L$ only appears as first and last location. It represents one iteration of the loop.
\end{mydef}

\jw{TODO 19.01 from here}

In this example $\tau_{L_1}$ is the minimal loop trace. \\

With the minimal loop trace it is possible to formulate the overall effect the loop has on the program state.
\begin{mydef}
	The loop relation $\psi_L$ describes the effect a loop has on the program state.
	Given the minimal looping trace $\tau_{min}: s_0, s_1, \ldots, s_{n}$ the loop relation can be constructed by using the composition of all program statements $s_i$.
	\begin{equation*}
		\psi_L = s_0; s_1; \cdots; s_n
	\end{equation*}

\end{mydef}
For $\tau_{L_1}$ the loop relation is $\psi_{L_1}:$ \texttt{x < 6; x := x + 2} \\
The loop relation can appear in a program trace an infinite amount of times, leading to infinitely many program traces. \\
It is however possible to contain every program trace going through a loop in a single relation, the so called reflexive transitive closure.
\begin{mydef}
	Given loop relation $\psi_L$, the reflexive transitive closure $\psi_L^*$ is a relation that includes every possible loop trace from every possible loop iteration. It is inductively defined as follows:
	\begin{itemize}
		\item $\psi^* = \bigvee_{i=0}^\infty \psi^i$
		\item $\psi^i = $
		$\begin{cases}
			& \varepsilon \hspace{1.5cm} \text{if}\ i = 0 \\
			& \psi; \psi^{i - 1} \hspace{0.5cm}\text{otherwise}
		\end{cases}$
	\end{itemize}
With identity relation $\varepsilon: \{(\sigma, \sigma')\ |\ \sigma = \sigma'\}$
\end{mydef}
There are multiple techniques of computing the reflexive transitive closure of a loop relation, this paper will focus on an algorithm based on ultimately periodic relations, as detailed in previous works. \jw{citation needed} 

 which we transform into a logical formula using definition TODO: $\phi_{L_1}: x_0 < 6 \land x_1 = x_0 + 2$. From $\phi_{L_1}$ we get the reflexive transitive closure:
\begin{equation*}
	\psi^*_{L_1}: x_0 = x_1 \lor x_0 < 6 \land x_1 = x_0 + 2
\end{equation*}



This reflexive transitive closure will be used in the following chapter to compute more general interpolants for trace abstraction.

\section{Accelerated Interpolation}
This section will introduce the technique of combining loop acceleration and interpolating trace abstraction. 
To check the reachability of $\ell_E$ we use the trace abstraction paradigm: \\
Firstly, we need a possible error trace $\tau_0$. \\ \\

\begin{figure}[H]
\begin{tikzpicture}[%
->,
>=stealth', shorten >=1pt, auto,
node distance=2.5cm, scale=1, 
transform shape, align=center,    
smallnode/.style={inner sep=1.4}
initial text =]

\node[state](1){$\ell_0$};

\node[state] (2) [right of=1] {$\ell_1$};

\node[state] (3) [right of=2] {$\ell_2$};

\node[state] (4) [right of=3, xshift=1cm] {$\ell_1$};

\node[state] (5) [right of=4] {$\ell_3$};

\node[state] (6) [right of=5] {$\ell_E$};

\path (1) edge node {$x_0 = 0$} (2); \\
\path (2) edge node {$x_0 < 6$} (3); \\
\path (3) edge node {$x_1 = x_0 + 2$} (4);\\
\path (4) edge node {$x_1 \geq 6$} (5); \\
\path (5) edge node {$x_1 \neq 6$} (6); \\
;
\end{tikzpicture}
	\captionof{figure}{$\tau_0$}
\end{figure}

\subsection{Meta-Traces}
The transitive closure of a loop contains every trace going through it. To make use of loop acceleration, we need to pull apart the looping location $\ell_2$ by introducing so called meta-transitions of the form:
\begin{equation*}
\overset{stm_3\ \circ \ stm_4}{\overset{\curvearrowright}{\ell_2}} \Rightarrow \hspace*{1cm} \ell_2' \xrightarrow{\text{$(stm_3 \circ stm_4)^*$}} \ell_2''
\end{equation*}
Where $(stm_3 \circ stm_4)^*$ symbolizes the calculated transitive closure of the loop. \par
Using meta-transitions, we can transform our trace scheme into a meta-trace:
\begin{equation*}
\bar{\tau}: \ell_0 \xrightarrow{\text{$stm_1$}} \ell_1 \xrightarrow{\text{$stm_2$}} \ell_2' \xrightarrow{\text{$(stm_3 \circ stm_4)^*$}} \ell_2'' \xrightarrow{\text{$stm_5$}} \ell_E
\end{equation*}
The feasibility of the meta-trace is the same as the trace scheme before: \\
\begin{itemize}
	\item  If it is feasible then the original trace is feasible, making the program incorrect
	\item If it is infeasible, we can compute an interpolant sequence: \\
	\begin{equation*}
	I_{\bar{\tau}}: \langle \top, I_1, I_2', I_2'', \bot  \rangle
	\end{equation*}
\end{itemize}

To guarantee inductiveness to the loop, we have to compute the strongest post of each interpolant, that coincide with a location in the loop, and its transitive closure:
\begin{equation*}
I_{\bar{\tau}}^{post}: \langle \top, I_1, post(I_2', stm_3 \circ stm_4), \bot  \rangle
\end{equation*}
This sequence is now general enough for the trace scheme to exclude the loop.

\jw{More Acceleration methods}

\pagebreak
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain}
\bibliography{bib}

	
\end{document}